<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>App de Câmera Android Completo</title>
    <style>
        body { margin: 0; font-family: Arial, sans-serif; background: #111; color: #fff; display: flex; flex-direction: column; align-items: center; }
        #modeSelector { margin-top: 20px; display: flex; gap: 10px; }
        #modeSelector button { padding: 10px 15px; border: none; border-radius: 6px; background: #333; color: #fff; }
        #modeSelector button:hover { background: #555; cursor: pointer; }
        #videoContainer, #photoContainer, #controls, #galleryContainer { width: 100%; max-width: 600px; margin-top: 20px; position: relative; }
        video, canvas, img { width: 100%; aspect-ratio: 9/16; object-fit: cover; border-radius: 8px; background: #000; }
        #controls { display: flex; flex-wrap: wrap; justify-content: space-around; margin-top: 10px; }
        button, select, input[type=range] { margin: 5px; padding: 10px; border: none; border-radius: 8px; background: #333; color: #fff; font-size: 1em; }
        button:hover, select:hover, input[type=range]:hover { background: #555; cursor: pointer; }
        input[type=range] { -webkit-appearance: none; background: transparent; width: 100%; margin: 10px 0; }
        input[type=range]:focus { outline: none; }
        input[type=range]::-webkit-slider-runnable-track { height: 4px; background: rgba(255,255,255,0.3); border-radius: 2px; }
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; width: 16px; height: 16px; background: #0f0; border-radius: 50%; margin-top: -6px; }
        input[type=range]::-moz-range-track { height: 4px; background: rgba(255,255,255,0.3); border-radius: 2px; }
        input[type=range]::-moz-range-thumb { width: 16px; height: 16px; background: #0f0; border-radius: 50%; border: none; }
        #zoomTicks, #zoomTicksVideo { display: flex; justify-content: space-between; font-size: 0.75em; margin-top: -8px; color: #888; }
        #optControls, #focusControls, #focusControlsPhoto { display: flex; flex-direction: column; margin-top: 10px; }
        #optControls label { margin: 5px 0; }
        #timerDisplay, #zoomDisplay, #fpsDisplay { font-size: 1em; margin: 5px; display: inline-block; background: rgba(0,0,0,0.5); padding: 4px 8px; border-radius: 4px; }
        #galleryItems { display: flex; flex-direction: column; gap: 10px; margin-top: 10px; }
        .gallery-item { position: relative; }
        .gallery-item img, .gallery-item video { max-height: 200px; border-radius: 6px; }
        .gallery-item button, .gallery-item a { position: absolute; top: 5px; right: 5px; padding: 5px; background: rgba(0,0,0,0.7); color: #fff; text-decoration: none; border-radius: 4px; font-size: 0.8em; }
        #gridToggleBtn { margin-top: 10px; }
        #gridOverlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: none; }
        #gridOverlay::before { background: 
            linear-gradient(to right, transparent 32%, rgba(255,255,255,0.5) 33%, rgba(255,255,255,0.5) 34%, transparent 35%, transparent 65%, rgba(255,255,255,0.5) 66%, rgba(255,255,255,0.5) 67%, transparent 68%),
            linear-gradient(to bottom, transparent 32%, rgba(255,255,255,0.5) 33%, rgba(255,255,255,0.5) 34%, transparent 35%, transparent 65%, rgba(255,255,255,0.5) 66%, rgba(255,255,255,0.5) 67%, transparent 68%);
          background-size: 100% 100%; background-repeat: no-repeat;
        }
        #focusOverlay, #focusOverlayPhoto { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: none; }
        #focusOverlay .focus-box, #focusOverlayPhoto .focus-box { position: absolute; top: 50%; left: 50%; width: 60%; height: 60%; transform: translate(-50%, -50%); border: 2px solid #0f0; }
        #toggleSR { position: absolute; top: 10px; right: 10px; background: rgba(255,255,255,0.2); padding: 6px 8px; border-radius: 6px; font-size: 0.9em; z-index: 10; }
        #toggleSR.enabled { background: rgba(0,200,0,0.4); }
    </style>
</head>
<body>
    <div id="modeSelector">
        <button id="photoModeBtn">Modo Foto</button>
        <button id="videoModeBtn">Modo Vídeo</button>
        <button id="galleryBtn">Galeria</button>
    </div>

    <!-- Container Vídeo -->
    <div id="videoContainer" style="display:none;">
        <video id="video" autoplay playsinline></video>
        <canvas id="pipView" style="position:absolute; top:10px; right:10px; border:2px solid #fff;"></canvas>
        <div id="zoomDisplay">1x</div>
        <div id="fpsDisplay">FPS: --</div>
        <button id="toggleSR">Super-Resolution: OFF</button>
    </div>

    <!-- Controles Gerais (vai mudar conforme modo) -->
    <div id="controls" style="display:none;"></div>

    <!-- Container Foto e Otimizações -->
    <div id="photoContainer" style="display:none;">
        <canvas id="photoCanvas"></canvas>
        <div id="focusOverlayPhoto"><div class="focus-box"></div></div>
        <!-- Barra de Zoom Foto -->
        <input type="range" id="zoomBar" min="0.5" max="100" step="0.1" value="1">
        <div id="zoomTicks">
            <span>0.5x</span><span>1x</span><span>2x</span><span>5x</span><span>10x</span><span>25x</span><span>50x</span><span>75x</span><span>100x</span>
        </div>
        <div id="focusControlsPhoto">
            <button id="autoFocusBtnPhoto">Foco Automático</button>
            <button id="manualFocusBtnPhoto">Foco Manual</button>
            <input type="range" id="focusSliderPhoto" min="0" max="1" step="0.01" value="0.5" style="display:none;">
        </div>
        <div id="optControls" style="display:none;">
            <label>Saturação: <input type="range" id="saturation" min="0" max="200" value="100"></label>
            <label>Brilho: <input type="range" id="brightness" min="0" max="200" value="100"></label>
            <label>Contraste: <input type="range" id="contrast" min="0" max="200" value="100"></label>
            <label>Nitidez: <input type="range" id="sharpness" min="0" max="200" value="100"></label>
            <button id="applyOptim">Aplicar Otimização</button>
            <button id="saveEditedPhotoBtn">Salvar Edição</button>
        </div>
        <button id="gridToggleBtn">Grade: Off</button>
    </div>

    <!-- Container Galeria -->
    <div id="galleryContainer" style="display:none;">
        <h3>Galeria</h3>
        <div id="galleryItems"></div>
        <button id="backToMainBtn">Voltar</button>
    </div>

    <script>
        const video = document.getElementById('video');
        const photoCanvas = document.getElementById('photoCanvas');
        const ctx = photoCanvas.getContext('2d');
        const controls = document.getElementById('controls');
        const photoContainer = document.getElementById('photoContainer');
        const optControls = document.getElementById('optControls');
        const galleryContainer = document.getElementById('galleryContainer');
        const galleryItems = document.getElementById('galleryItems');
        const timerDisplay = document.createElement('div');
        const pauseBtn = document.createElement('button'); pauseBtn.textContent = 'Pausar'; pauseBtn.style.display = 'none';
        const resumeBtn = document.createElement('button'); resumeBtn.textContent = 'Retomar'; resumeBtn.style.display = 'none';
        const stopBtn = document.createElement('button'); stopBtn.textContent = 'Encerrar'; stopBtn.style.display = 'none';
        const micToggleBtn = document.createElement('button'); micToggleBtn.textContent = 'Mic: On'; micToggleBtn.style.background = '#0066cc';
        const zoomDisplay = document.getElementById('zoomDisplay');
        const fpsDisplay = document.getElementById('fpsDisplay');
        const gridOverlay = document.getElementById('gridOverlay');
        const gridToggleBtn = document.getElementById('gridToggleBtn');
        const zoomBar = document.getElementById('zoomBar');
        const pipView = document.getElementById('pipView');
        const toggleSRBtn = document.getElementById('toggleSR');

        const focusOverlay = document.getElementById('focusOverlay');
        const focusOverlayPhoto = document.getElementById('focusOverlayPhoto');
        const autoFocusBtnVideo = document.createElement('button'); autoFocusBtnVideo.textContent = 'Foco Automático';
        const manualFocusBtnVideo = document.createElement('button'); manualFocusBtnVideo.textContent = 'Foco Manual';
        const focusSliderVideo = document.createElement('input'); focusSliderVideo.type = 'range'; focusSliderVideo.min = 0; focusSliderVideo.max = 1; focusSliderVideo.step = 0.01; focusSliderVideo.value = 0.5; focusSliderVideo.style.display = 'none';
        const autoFocusBtnPhoto = document.getElementById('autoFocusBtnPhoto');
        const manualFocusBtnPhoto = document.getElementById('manualFocusBtnPhoto');
        const focusSliderPhoto = document.getElementById('focusSliderPhoto');

        const videoContainer = document.getElementById('videoContainer');
        const recordControls = document.createElement('div'); recordControls.id = 'recordControls'; recordControls.style.display = 'none';

        let currentMode = null;
        let stream = null;
        let mediaRecorder = null;
        let recordedChunks = [];
        let recordStartTime = 0;
        let recordTimerInterval = null;
        let isPaused = false;
        let includeAudio = false;
        let useSuperRes = false; // controla se usa multi-frame super-res

        const photos = [];
        const videos = [];
        let editingPhotoIndex = null;

        let currentZoom = 1;
        let maxOpticalZoom = 1;
        let minOpticalZoom = 1;

        let lastFrameTime = performance.now();
        let frameCount = 0;

        // Inicia câmera genérica (modo contínuo de foco, sem áudio)
        async function initCamera(constraints) {
            if (stream) stream.getTracks().forEach(t => t.stop());
            try {
                stream = await navigator.mediaDevices.getUserMedia(constraints);
                video.srcObject = stream;
                const [track] = stream.getVideoTracks();
                const cap = track.getCapabilities();
                maxOpticalZoom = cap.zoom ? (cap.zoom.max || 1) : 1;
                minOpticalZoom = cap.zoom ? (cap.zoom.min || 1) : 1;
                currentZoom = 1;
                updateZoomDisplay();
                video.style.transform = 'scale(1)';
                videoContainer.style.display = 'block';
                controls.style.display = 'flex';
                startFPSCounter();
            } catch (e) {
                const errName = e.name;
                if (['OverconstrainedError', 'NotReadableError', 'NotSupportedError'].includes(errName)) {
                    alert('Qualidade não suportada pela câmera.');
                } else if (errName === 'NotAllowedError') {
                    alert('Permissão negada para câmera.');
                } else {
                    alert('Erro ao acessar câmera: ' + e.message);
                }
                console.error('Erro getUserMedia:', e);
            }
        }

        // Formata tempo mm:ss
        function formatTime(seconds) {
            const m = String(Math.floor(seconds / 60)).padStart(2, '0');
            const s = String(seconds % 60).padStart(2, '0');
            return `${m}:${s}`;
        }

        function startTimer() {
            recordStartTime = 0;
            timerDisplay.textContent = '00:00';
            recordTimerInterval = setInterval(() => {
                if (!isPaused) {
                    recordStartTime++;
                    timerDisplay.textContent = formatTime(recordStartTime);
                }
            }, 1000);
            pauseBtn.style.display = 'inline-block';
            stopBtn.style.display = 'inline-block';
        }

        function stopTimer() {
            clearInterval(recordTimerInterval);
            timerDisplay.textContent = '00:00';
            pauseBtn.style.display = 'none';
            resumeBtn.style.display = 'none';
            stopBtn.style.display = 'none';
            isPaused = false;
        }

        function clearControls() {
            controls.innerHTML = '';
            photoContainer.style.display = 'none';
            optControls.style.display = 'none';
            recordControls.style.display = 'none';
            videoContainer.style.display = 'none';
        }

        // ------- Modo Foto -------
        function setupPhotoMode() {
            currentMode = 'photo';
            clearControls();
            hideAllSections();
            videoContainer.style.display = 'block';
            controls.style.display = 'flex';
            photoContainer.style.display = 'block';

            // Zoom foto: botões fixos e slider
            const zValues = [0.5, 1, 2, 5, 10, 25, 50, 75, 100];
            zValues.forEach(z => {
                const btn = document.createElement('button');
                btn.textContent = z + 'x';
                btn.onclick = () => setZoom(z);
                controls.appendChild(btn);
            });
            zoomBar.min = 0.5; zoomBar.max = 100; zoomBar.step = 0.1; zoomBar.value = 1;
            zoomBar.oninput = () => setZoom(zoomBar.value);
            controls.appendChild(zoomBar);

            const captureBtn = document.createElement('button');
            captureBtn.textContent = 'Capturar Foto';
            captureBtn.onclick = () => {
                if (useSuperRes) takeEnhancedPhoto();
                else captureSinglePhoto();
            };
            controls.appendChild(captureBtn);

            // Foco (foto)
            autoFocusBtnPhoto.onclick = () => setFocusMode('continuous');
            manualFocusBtnPhoto.onclick = () => { focusSliderPhoto.style.display = 'inline-block'; focusOverlayPhoto.style.display = 'block'; };
            focusSliderPhoto.oninput = () => setManualFocus(focusSliderPhoto.value);
            focusSliderPhoto.style.display = 'none';

            optControls.style.display = 'none';
            photoContainer.appendChild(optControls);
            document.getElementById('applyOptim').onclick = applyOptimizations;
            document.getElementById('saveEditedPhotoBtn').onclick = saveEditedPhoto;

            gridToggleBtn.onclick = toggleGrid;
        }

        async function setZoom(value) {
            const zoomRequested = parseFloat(value);
            const [track] = stream.getVideoTracks();
            const cap = track.getCapabilities();
            if (cap.zoom) {
                try {
                    await track.applyConstraints({ advanced: [{ zoom: zoomRequested }] });
                    video.style.transform = 'scale(1)';
                } catch {
                    const minZ = cap.zoom.min;
                    const maxZ = cap.zoom.max;
                    if (zoomRequested < minZ) {
                        await track.applyConstraints({ advanced: [{ zoom: minZ }] });
                        const digital = zoomRequested / minZ;
                        video.style.transform = `scale(${digital})`;
                    } else if (zoomRequested > maxZ) {
                        await track.applyConstraints({ advanced: [{ zoom: maxZ }] });
                        const digital = zoomRequested / maxZ;
                        video.style.transform = `scale(${digital})`;
                    } else {
                        video.style.transform = 'scale(1)';
                    }
                }
            } else {
                video.style.transform = `scale(${zoomRequested})`;
            }
            currentZoom = zoomRequested;
            zoomBar.value = zoomRequested;
            updateZoomDisplay();
        }

        function updateZoomDisplay() {
            zoomDisplay.textContent = `${currentZoom}x`;
        }

        function captureSinglePhoto() {
            if (!stream) return;
            const [track] = stream.getVideoTracks();
            const settings = track.getSettings();
            const width = settings.width || video.videoWidth;
            const height = settings.height || video.videoHeight;
            if (!width || !height) {
                alert('Não foi possível obter resolução da câmera.');
                return;
            }
            photoCanvas.width = width;
            photoCanvas.height = height;
            const ctx2 = photoCanvas.getContext('2d');
            ctx2.imageSmoothingEnabled = true;
            ctx2.imageSmoothingQuality = 'high';
            ctx2.drawImage(video, 0, 0, width, height);
            sharpenCanvas(photoCanvas);
            downloadCanvasImage();
        }

        async function takeEnhancedPhoto() {
            if (!stream) return;
            const [track] = stream.getVideoTracks();
            const settings = track.getSettings();
            const width = settings.width || video.videoWidth;
            const height = settings.height || video.videoHeight;
            if (!width || !height) {
                alert('Não foi possível obter resolução da câmera.');
                return;
            }
            photoCanvas.width = width;
            photoCanvas.height = height;

            const framesToCapture = 5;
            const tempCanv = document.createElement('canvas');
            const tempCtx = tempCanv.getContext('2d');
            tempCanv.width = width;
            tempCanv.height = height;
            const accumR = new Float32Array(width * height);
            const accumG = new Float32Array(width * height);
            const accumB = new Float32Array(width * height);

            for (let i = 0; i < framesToCapture; i++) {
                tempCtx.drawImage(video, 0, 0, width, height);
                const imgData = tempCtx.getImageData(0, 0, width, height).data;
                for (let p = 0; p < width * height; p++) {
                    const idx = p * 4;
                    accumR[p] += imgData[idx];
                    accumG[p] += imgData[idx + 1];
                    accumB[p] += imgData[idx + 2];
                }
                await new Promise(r => setTimeout(r, 80));
            }

            const finalImg = ctx.createImageData(width, height);
            for (let p = 0; p < width * height; p++) {
                const idx = p * 4;
                finalImg.data[idx] = Math.round(accumR[p] / framesToCapture);
                finalImg.data[idx + 1] = Math.round(accumG[p] / framesToCapture);
                finalImg.data[idx + 2] = Math.round(accumB[p] / framesToCapture);
                finalImg.data[idx + 3] = 255;
            }
            ctx.putImageData(finalImg, 0, 0);
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
            sharpenCanvas(photoCanvas);
            downloadCanvasImage();
        }

        function downloadCanvasImage() {
            const a = document.createElement('a');
            a.href = photoCanvas.toDataURL('image/jpeg', 0.9);
            a.download = `foto-${Date.now()}.jpg`;
            a.click();
        }

        function applyOptimizations() {
            const imgData = ctx.getImageData(0, 0, photoCanvas.width, photoCanvas.height);
            const data = imgData.data;
            const sat = document.getElementById('saturation').value / 100;
            const bri = document.getElementById('brightness').value / 100;
            const con = document.getElementById('contrast').value / 100;
            const sharp = document.getElementById('sharpness').value / 100;
            for (let i = 0; i < data.length; i += 4) {
                data[i] = data[i] * sat * con + 255 * (bri - 1);
                data[i + 1] = data[i + 1] * sat * con + 255 * (bri - 1);
                data[i + 2] = data[i + 2] * sat * con + 255 * (bri - 1);
            }
            ctx.putImageData(imgData, 0, 0);
            if (sharp !== 1) {
                const kernel = [0, -1, 0, -1, 5, -1, 0, -1, 0];
                const divisor = sharp;
                const tempCanvas = document.createElement('canvas');
                const tCtx = tempCanvas.getContext('2d');
                tempCanvas.width = photoCanvas.width;
                tempCanvas.height = photoCanvas.height;
                tCtx.drawImage(photoCanvas, 0, 0);
                const src = tCtx.getImageData(0, 0, photoCanvas.width, photoCanvas.height);
                const dst = ctx.createImageData(photoCanvas.width, photoCanvas.height);
                for (let y = 1; y < photoCanvas.height - 1; y++) {
                    for (let x = 1; x < photoCanvas.width - 1; x++) {
                        let sumR = 0, sumG = 0, sumB = 0;
                        for (let ky = -1; ky <= 1; ky++) {
                            for (let kx = -1; kx <= 1; kx++) {
                                const weight = kernel[(ky + 1) * 3 + (kx + 1)];
                                const srcIdx = ((y + ky) * photoCanvas.width + (x + kx)) * 4;
                                sumR += src.data[srcIdx] * weight;
                                sumG += src.data[srcIdx + 1] * weight;
                                sumB += src.data[srcIdx + 2] * weight;
                            }
                        }
                        const idx = (y * photoCanvas.width + x) * 4;
                        dst.data[idx] = Math.min(Math.max(sumR / divisor, 0), 255);
                        dst.data[idx + 1] = Math.min(Math.max(sumG / divisor, 0), 255);
                        dst.data[idx + 2] = Math.min(Math.max(sumB / divisor, 0), 255);
                        dst.data[idx + 3] = src.data[idx + 3];
                    }
                }
                ctx.putImageData(dst, 0, 0);
            }
        }

        function saveEditedPhoto() {
            const dataUrl = photoCanvas.toDataURL('image/png');
            if (editingPhotoIndex !== null) {
                photos[editingPhotoIndex].dataUrl = dataUrl;
            } else {
                photos.push({ dataUrl });
            }
            optControls.style.display = 'none';
        }

        function toggleGrid() {
            const isOn = gridOverlay.style.display === 'block';
            gridOverlay.style.display = isOn ? 'none' : 'block';
            gridToggleBtn.style.background = isOn ? '#333' : '#0066cc';
            gridToggleBtn.textContent = `Grade: ${isOn ? 'Off' : 'On'}`;
        }

        async function setFocusMode(mode) {
            const track = stream.getVideoTracks()[0];
            const cap = track.getCapabilities();
            if (cap.focusMode) {
                try {
                    await track.applyConstraints({ advanced: [{ focusMode: mode }] });
                    if (mode === 'continuous') {
                        focusOverlay.style.display = 'none';
                        focusOverlayPhoto.style.display = 'none';
                        focusSliderVideo.style.display = 'none';
                        focusSliderPhoto.style.display = 'none';
                    }
                } catch (e) { console.warn('Foco não suportado:', e); }
            }
        }

        async function setManualFocus(value) {
            const track = stream.getVideoTracks()[0];
            const cap = track.getCapabilities();
            if (cap.focusDistance) {
                try {
                    await track.applyConstraints({ advanced: [{ focusMode: 'manual', focusDistance: parseFloat(value) }] });
                    if (currentMode === 'video') {
                        focusOverlay.style.display = 'block';
                    } else if (currentMode === 'photo') {
                        focusOverlayPhoto.style.display = 'block';
                    }
                } catch (e) { console.warn('Foco manual não suportado:', e); }
            }
        }

        function sharpenCanvas(canv) {
            const ctx2 = canv.getContext('2d');
            const w = canv.width, h = canv.height;
            const src = ctx2.getImageData(0, 0, w, h);
            const dst = ctx2.createImageData(w, h);
            const kernel = [0, -1, 0, -1, 5, -1, 0, -1, 0];
            for (let y = 1; y < h - 1; y++) {
                for (let x = 1; x < w - 1; x++) {
                    let sumR = 0, sumG = 0, sumB = 0;
                    for (let ky = -1; ky <= 1; ky++) {
                        for (let kx = -1; kx <= 1; kx++) {
                            const weight = kernel[(ky + 1) * 3 + (kx + 1)];
                            const idx = ((y + ky) * w + (x + kx)) * 4;
                            sumR += src.data[idx] * weight;
                            sumG += src.data[idx + 1] * weight;
                            sumB += src.data[idx + 2] * weight;
                        }
                    }
                    const i = (y * w + x) * 4;
                    dst.data[i]     = Math.min(Math.max(sumR, 0), 255);
                    dst.data[i + 1] = Math.min(Math.max(sumG, 0), 255);
                    dst.data[i + 2] = Math.min(Math.max(sumB, 0), 255);
                    dst.data[i + 3] = src.data[i + 3];
                }
            }
            ctx2.putImageData(dst, 0, 0);
        }

        function startFPSCounter() {
            let last = performance.now();
            let count = 0;
            function loop() {
                const now = performance.now();
                count++;
                if (now - last >= 1000) {
                    fpsDisplay.textContent = `FPS: ${count}`;
                    count = 0;
                    last = now;
                }
                drawPIP();
                requestAnimationFrame(loop);
            }
            requestAnimationFrame(loop);
        }

        function drawPIP() {
            if (!stream) return;
            const ctxP = document.getElementById('pipView').getContext('2d');
            const w = 100, h = 178;
            ctxP.clearRect(0, 0, w, h);
            ctxP.drawImage(video, 0, 0, w, h);
            const [track] = stream.getVideoTracks();
            const cap = track.getCapabilities();
            const minZ = cap.zoom ? cap.zoom.min : 1;
            const maxZ = cap.zoom ? cap.zoom.max : 1;
            let digital = 1;
            if (currentZoom < minZ) digital = minZ / currentZoom;
            else if (currentZoom > maxZ) digital = currentZoom / maxZ;
            const rectW = w / digital;
            const rectH = h / digital;
            ctxP.strokeStyle = 'yellow';
            ctxP.lineWidth = 2;
            ctxP.strokeRect((w - rectW) / 2, (h - rectH) / 2, rectW, rectH);
        }

        function showGallery() {
            hideAllSections();
            galleryContainer.style.display = 'block';
            renderGallery();
        }

        function renderGallery() {
            galleryItems.innerHTML = '';
            photos.forEach((photo, index) => {
                const div = document.createElement('div');
                div.className = 'gallery-item';
                const img = document.createElement('img');
                img.src = photo.dataUrl;
                div.appendChild(img);
                const dlBtn = document.createElement('a');
                dlBtn.textContent = 'Download';
                dlBtn.href = photo.dataUrl;
                dlBtn.download = `foto_${index + 1}.png`;
                div.appendChild(dlBtn);
                const editBtn = document.createElement('button');
                editBtn.textContent = 'Editar';
                editBtn.onclick = () => editPhoto(index);
                div.appendChild(editBtn);
                galleryItems.appendChild(div);
            });
            videos.forEach((videoObj, index) => {
                const div = document.createElement('div');
                div.className = 'gallery-item';
                const vid = document.createElement('video');
                const url = URL.createObjectURL(videoObj.blob);
                vid.src = url;
                vid.controls = true;
                div.appendChild(vid);
                const dlBtn = document.createElement('a');
                dlBtn.textContent = 'Download';
                dlBtn.href = url;
                dlBtn.download = `video_${index + 1}.webm`;
                div.appendChild(dlBtn);
                galleryItems.appendChild(div);
            });
        }

        function editPhoto(index) {
            const photo = photos[index];
            hideAllSections();
            photoContainer.style.display = 'block';
            optControls.style.display = 'flex';
            const img = new Image();
            img.onload = () => {
                photoCanvas.width = img.width;
                photoCanvas.height = img.height;
                ctx.drawImage(img, 0, 0);
            };
            img.src = photo.dataUrl;
            editingPhotoIndex = index;
        }

        function hideAllSections() {
            videoContainer.style.display = 'none';
            controls.style.display = 'none';
            recordControls.style.display = 'none';
            photoContainer.style.display = 'none';
            optControls.style.display = 'none';
            galleryContainer.style.display = 'none';
            focusOverlay.style.display = 'none';
            focusOverlayPhoto.style.display = 'none';
            focusSliderVideo.style.display = 'none';
            focusSliderPhoto.style.display = 'none';
        }

        document.getElementById('photoModeBtn').onclick = async () => {
            hideAllSections();
            await initCamera({ video: { facingMode: 'environment', focusMode: 'continuous' }, audio: false });
            setupPhotoMode();
        };
        document.getElementById('videoModeBtn').onclick = async () => {
            hideAllSections();
            await initCamera({ video: { width: { exact: 1920 }, height: { exact: 1080 }, facingMode: 'environment', focusMode: 'continuous' }, audio: true });
            setupVideoMode();
        };
        document.getElementById('galleryBtn').onclick = () => showGallery();
        document.getElementById('backToMainBtn').onclick = () => hideAllSections();

        function setupVideoMode() {
            currentMode = 'video';
            clearControls();
            hideAllSections();
            videoContainer.style.display = 'block';
            controls.style.display = 'flex';
            recordControls.style.display = 'block';
            recordControls.appendChild(timerDisplay);
            recordControls.appendChild(micToggleBtn);

            const resolutions = ["480p", "720p", "1080p", "1440p", "2160p"];
            const sel = document.createElement('select');
            resolutions.forEach(res => {
                const option = document.createElement('option');
                option.value = res;
                option.textContent = res;
                sel.appendChild(option);
            });
            sel.onchange = () => changeVideoResolution(sel.value);
            controls.appendChild(sel);

            const btn1 = document.createElement('button'); btn1.textContent = '1x'; btn1.onclick = () => setZoom(1);
            const btn2 = document.createElement('button'); btn2.textContent = '2x'; btn2.onclick = () => setZoom(2);
            controls.appendChild(btn1);
            controls.appendChild(btn2);

            autoFocusBtnVideo.onclick = () => setFocusMode('continuous');
            manualFocusBtnVideo.onclick = () => { focusSliderVideo.style.display = 'inline-block'; focusOverlay.style.display = 'block'; };
            focusSliderVideo.oninput = () => setManualFocus(focusSliderVideo.value);
            focusSliderVideo.style.display = 'none';
            controls.appendChild(autoFocusBtnVideo);
            controls.appendChild(manualFocusBtnVideo);
            controls.appendChild(focusSliderVideo);

            const recordBtn = document.createElement('button');
            recordBtn.textContent = 'Iniciar Gravação';
            recordBtn.onclick = startRecording;
            controls.appendChild(recordBtn);

            pauseBtn.onclick = pauseRecording;
            resumeBtn.onclick = resumeRecording;
            stopBtn.onclick = stopRecording;
            micToggleBtn.onclick = toggleMic;
        }

        async function changeVideoResolution(label) {
            const mapping = {
                "480p": { video: { width: { exact: 640 }, height: { exact: 480 }, facingMode: 'environment', focusMode: 'continuous' }, audio: true },
                "720p": { video: { width: { exact: 1280 }, height: { exact: 720 }, facingMode: 'environment', focusMode: 'continuous' }, audio: true },
                "1080p": { video: { width: { exact: 1920 }, height: { exact: 1080 }, facingMode: 'environment', focusMode: 'continuous' }, audio: true },
                "1440p": { video: { width: { exact: 2560 }, height: { exact: 1440 }, facingMode: 'environment', focusMode: 'continuous' }, audio: true },
                "2160p": { video: { width: { exact: 3840 }, height: { exact: 2160 }, facingMode: 'environment', focusMode: 'continuous' }, audio: true }
            };
            try {
                await initCamera(mapping[label]);
                setupVideoMode();
            } catch {
                alert(`Resolução ${label} não suportada, usando 1080p.`);
                await initCamera(mapping["1080p"]);
                setupVideoMode();
            }
        }

        function startRecording() {
            if (!stream) return;
            recordedChunks = [];
            try {
                mediaRecorder = new MediaRecorder(stream, { mimeType: 'video/webm; codecs=vp9' });
            } catch (e) {
                alert('MediaRecorder não suportado neste navegador.');
                return;
            }
            mediaRecorder.ondataavailable = e => { if (e.data.size > 0) recordedChunks.push(e.data); };
            mediaRecorder.onstop = () => {
                const blob = new Blob(recordedChunks, { type: 'video/webm' });
                const a = document.createElement('a');
                a.href = URL.createObjectURL(blob);
                a.download = `video-${Date.now()}.webm`;
                a.click();
                stopTimer();
            };
            mediaRecorder.start();
            startTimer();
        }

        function pauseRecording() {
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                mediaRecorder.pause();
                isPaused = true;
                pauseBtn.style.display = 'none';
                resumeBtn.style.display = 'inline-block';
            }
        }

        function resumeRecording() {
            if (mediaRecorder && mediaRecorder.state === 'paused') {
                mediaRecorder.resume();
                isPaused = false;
                resumeBtn.style.display = 'none';
                pauseBtn.style.display = 'inline-block';
            }
        }

        function stopRecording() {
            if (mediaRecorder && mediaRecorder.state !== 'inactive') mediaRecorder.stop();
        }

        function toggleMic() {
            includeAudio = !includeAudio;
            micToggleBtn.style.background = includeAudio ? '#0066cc' : '#333';
            micToggleBtn.textContent = `Mic: ${includeAudio ? 'On' : 'Off'}`;
            if (stream) stream.getAudioTracks().forEach(t => t.enabled = includeAudio);
        }

        document.addEventListener('DOMContentLoaded', async () => {
            hideAllSections();
        });
    </script>
</body>
</html>
